! Собранный .jar-файл находится ./build/libs
Для проверки реализованных методов в проекте "heroes", директории "jars" необходимо заменить существующий obf.jar файл на данный файл.

GeneratePresetImpl (жадный алгоритм по принципу эффективность(здоровье/атака)/стоимость, или жадный вариант «рюкзака»)
1. Инициализация структуры данных. Проход по UnitList. Сложность: O(n).
2. Сортировка типов юнитов по коэффициентам атака/стоимость и здоровье/стоимость. Сложность: O(n log n).
3. Формирование армии через цикл while, внутри которого происходит проход по всем типам юнитов, так как за каждую итерацию добавляется не более n юнитов, а общее количество добавленных юнитов ограничено m, суммарная сложность этого этапа составляет O(m).
4. Генерация уникальных координат для всех юнитов выполняется не более m раз, при этом операции с HashSet имеют среднюю сложность O(1), поэтому вклад этого этапа также равен O(m).
5. Формирование объекта Army выполняется за O(1)
Суммарная сложность алгоритма: O(n log n + m), что является лучше требуемой по документации сложности O(n·m).

SimmulateBattleImpl (использован «жадный» подход для выбора целей)
1. Инициализация очереди ходов, проход по списку обеих армий. Проверка условием IsAlive() задаёт сложность O(n).
2. Сортируем очередь по параметру BaseAttack стандартным TimSort (O(n log n) в худшем случае)
3. Основной цикл симуляции while продолжается, пока есть живые юниты в обеих армиях и очередь не пуста. Внутри цикла используется Iterator по очереди; для каждого юнита проверка isAlive() - O(1); вызов unit.getProgram().attack() - O(n); логирование и Thread.sleep(50) — O(1). Если юнит погибает - он удаляется из очереди, а после раунда очередь пересортировывается только если были смерти. Таким образом, один проход по очереди (до n юнитов) даёт O(n·n) = O(n²) для всех атак.
4. Пересортировка очереди при смерти юнитов: максимум n смертей, каждая пересортировка - O(n log n), суммарно это даёт O(n² log n).
Суммарную сложность вычисляем по доминирующему члену, то есть - O(n² log n), что соответствует требованиям задания.

SuitableForAttackUnitsFinderImpl
Метод getSuitableUnits проходит по всем рядам (m итераций) и по всем юнитам в каждом ряду (n итераций), внутри выполняются только проверки состояния юнита и соседей (O(1)), поэтому суммарная сложность равна O(m·n). Так как количество рядов фиксировано (m = 3), фактически сложность линейная по числу юнитов в ряду, то есть O(n), что соответствует требованиям задания.

UnitTargetPathFinder (метод А*)
1. Создание массива blocked и проход по списку existingUnitList (помечаем живых юнитов как препятствия). Сложность: O(n).
2. Проверка стартовой и конечной позиции. Сложность: O(1).
3. Инициализация узла A* и открытой очереди (PriorityQueue). Сложность: O(1).
4. Основной цикл A*. Пока есть узлы в очереди open: 
•	Извлекаем узел с минимальным f (O(log N), где N — количество элементов в очереди).
•	Проверяем достижение цели (O(1)).
•	Отмечаем текущую клетку как посещённую (O(1)).
•	Проходим по 8 направлениям (DIRECTIONS) - O(1) на каждое.
•	Для каждой соседней клетки вычисляем g и f, добавляем в open (O(log N)).

В худшем случае A* может обработать все клетки поля, то есть WIDTH × HEIGHT = W × H. Каждая операция добавления/извлечения из PriorityQueue - O(log(W·H)). Итого сложность основного цикла: A*: O((W·H) · log(W·H)). А* является доминирующим членом алгоритма, берём его сложность как итоговую: O((W·H) · log(W·H)). Эта сложность соответствует требованиям задания.




